/*
	JSON-to-Python
	Based on JSON-to-Go
	by Matt Holt

	https://github.com/mholt/json-to-go

	A simple utility to translate JSON into a Python dataclass.
*/

function jsonToPython(json, typename, flatten = true) {
  let data;
  let scope;
  let python = "";
  let tabs = 0;

  const seen = {};
  const stack = [];
  let accumulator = "";
  let innerTabs = 0;
  let parent = "";

  try {
    data = JSON.parse(json.replace(/:(\s*\d*)\.0/g, ":$1.1")); // hack that forces floats to stay as floats
    scope = data;
  } catch (e) {
    return {
      python: "",
      error: e.message
    };
  }

  typename = format(typename || "AutoGenerated");
  append(`@dataclass\nclass ${typename}`);

  parseScope(scope);

  return {
    python: flatten ? (python += accumulator) : python
  };

  function parseScope(scope, depth = 0) {
    if (typeof scope === "object" && scope !== null) {
      if (Array.isArray(scope)) {
        let sliceType;
        const scopeLength = scope.length;

        for (let i = 0; i < scopeLength; i++) {
          const thisType = pythonType(scope[i]);
          if (!sliceType) sliceType = thisType;
          else if (sliceType != thisType) {
            sliceType = mostSpecificPossiblePythonType(thisType, sliceType);
            if (sliceType == "Any") break;
          }
        }

        const slice =
          flatten && ["Dict", "List"].includes(sliceType)
            ? `[]${parent}`
            : `[]`;

        if (flatten && depth >= 2) appender(slice);
        else append(slice);
        if (sliceType == "Dict") {
          const allFields = {};

          // for each field counts how many times appears
          for (let i = 0; i < scopeLength; i++) {
            const keys = Object.keys(scope[i]);
            for (let k in keys) {
              let keyname = keys[k];
              if (!(keyname in allFields)) {
                allFields[keyname] = {
                  value: scope[i][keyname],
                  count: 0
                };
              } else {
                const existingValue = allFields[keyname].value;
                const currentValue = scope[i][keyname];

                if (compareObjects(existingValue, currentValue)) {
                  const comparisonResult = compareObjectKeys(
                    Object.keys(currentValue),
                    Object.keys(existingValue)
                  );
                  if (!comparisonResult) {
                    keyname = `${keyname}_${uuidv4()}`;
                    allFields[keyname] = {
                      value: currentValue,
                      count: 0
                    };
                  }
                }
              }
              allFields[keyname].count++;
            }
          }

          // create a common struct with all fields found in the current array
          // omitempty dict indicates if a field is optional
          const keys = Object.keys(allFields),
            struct = {},
            omitempty = {};
          for (let k in keys) {
            const keyname = keys[k],
              elem = allFields[keyname];

            struct[keyname] = elem.value;
            omitempty[keyname] = elem.count != scopeLength;
          }
          parseDataclass(depth + 1, innerTabs, struct, omitempty); // finally parse the struct !!
        } else if (sliceType == "List") {
          parseScope(scope[0], depth);
        } else {
          if (flatten && depth >= 2) {
            appender(sliceType || "Any");
          } else {
            append(sliceType || "Any");
          }
        }
      } else {
        if (flatten) {
          if (depth >= 2) {
            appender(parent);
          } else {
            append(parent);
          }
        }
        parseDataclass(depth + 1, innerTabs, scope);
      }
    } else {
      if (flatten && depth >= 2) {
        appender(pythonType(scope));
      } else {
        append(pythonType(scope));
      }
    }
  }

  function parseDataclass(depth, innerTabs, scope, omitempty) {
    if (flatten) {
      stack.push(depth >= 2 ? "\n" : "");
    }

    const _flatten = flatten && depth >= 2;
    if (_flatten) {
      const parentType = `@dataclass\nclass ${parent}`;
      const scopeKeys = formatScopeKeys(Object.keys(scope));

      // this can only handle two duplicate items
      // future improvement will handle the case where there could
      // three or more duplicate keys with different values
      if (parent in seen && compareObjectKeys(scopeKeys, seen[parent])) {
        stack.pop();
        return;
      }
      seen[parent] = scopeKeys;

      appender(`${parentType}:\n`);
      ++innerTabs;
    } else if (flatten || depth < 2) {
      append(":\n");
      ++tabs;
    } else {
      append(`${parent}\n`);
      indent(tabs);
      append(`class ${parent}:\n`);
      ++tabs;
    }

    const keys = Object.keys(scope);
    const _appender = _flatten ? appender : append;
    const _indenter = _flatten ? indenter : indent;
    for (let i in keys) {
      const keyname = getOriginalName(keys[i]);
      _indenter(_flatten ? innerTabs : tabs);
      const typename = formatSnake(keyname);
      _appender(typename + ": ");
      parent = format(keyname);
      parseScope(scope[keys[i]], depth);
      const _omitempty = omitempty && omitempty[keys[i]] === true;
      if (typename !== keyname || _omitempty) {
        _appender(' = field(metadata={"json":"' + keyname + '"');
        if (_omitempty) {
          _appender(',metadata={"omit_empty": True}');
        }
        _appender("})");
      }
      _appender("\n");
    }

    if (flatten && depth >= 2) {
      --innerTabs;
    } else {
      --tabs;
    }
    if (flatten) accumulator += stack.pop();
  }

  function indent(tabs) {
    for (let i = 0; i < tabs; i++) python += "\t";
  }

  function append(str) {
    python += str;
  }

  function indenter(tabs) {
    for (let i = 0; i < tabs; i++) stack[stack.length - 1] += "\t";
  }

  function appender(str) {
    stack[stack.length - 1] += str;
  }

  // Sanitizes and formats a string to make an appropriate identifier in Python
  function format(str) {
    if (!str) return "";
    else if (str.match(/^\d+$/)) str = "Num" + str;
    else if (str.charAt(0).match(/\d/)) {
      const numbers = {
        "0": "Zero_",
        "1": "One_",
        "2": "Two_",
        "3": "Three_",
        "4": "Four_",
        "5": "Five_",
        "6": "Six_",
        "7": "Seven_",
        "8": "Eight_",
        "9": "Nine_"
      };
      str = numbers[str.charAt(0)] + str.substr(1);
    }
    return toProperCase(str).replace(/[^a-z0-9]/gi, "") || "NAMING_FAILED";
  }

  // Sanitizes and formats a string to make an appropriate identifier in Python
  function formatSnake(str) {
    if (!str) return "";
    else if (str.match(/^\d+$/)) str = "num_" + str;
    else if (str.charAt(0).match(/\d/)) {
      const numbers = {
        "0": "Zero_",
        "1": "One_",
        "2": "Two_",
        "3": "Three_",
        "4": "Four_",
        "5": "Five_",
        "6": "Six_",
        "7": "Seven_",
        "8": "Eight_",
        "9": "Nine_"
      };
      str = numbers[str.charAt(0)] + str.substr(1);
    }
    return str.toLowerCase().replace(/[^a-z0-9_]/gi, "") || "NAMING_FAILED";
  }

  // Determines the most appropriate Python type
  function pythonType(val) {
    if (val === null) return "Any";

    switch (typeof val) {
      case "string":
        if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val))
          return "time.Time";
        else return "str";
      case "number":
        if (val % 1 === 0) {
          if (val > -2147483648 && val < 2147483647) return "int";
          else return "int";
        } else return "float";
      case "boolean":
        return "bool";
      case "object":
        if (Array.isArray(val)) return "List";
        return "Dict";
      default:
        return "Any";
    }
  }

  // Given two types, returns the more specific of the two
  function mostSpecificPossiblePythonType(typ1, typ2) {
    if (typ1.substr(0, 5) == "float" && typ2.substr(0, 3) == "int") return typ1;
    else if (typ1.substr(0, 3) == "int" && typ2.substr(0, 5) == "float")
      return typ2;
    else return "Any";
  }

  // Proper cases a string according to go conventions
  function toProperCase(str) {
    // https://github.com/golang/lint/blob/5614ed5bae6fb75893070bdc0996a68765fdd275/lint.go#L771-L810
    const commonInitialisms = [
      "ACL",
      "API",
      "ASCII",
      "CPU",
      "CSS",
      "DNS",
      "EOF",
      "GUID",
      "HTML",
      "HTTP",
      "HTTPS",
      "ID",
      "IP",
      "JSON",
      "LHS",
      "QPS",
      "RAM",
      "RHS",
      "RPC",
      "SLA",
      "SMTP",
      "SQL",
      "SSH",
      "TCP",
      "TLS",
      "TTL",
      "UDP",
      "UI",
      "UID",
      "UUID",
      "URI",
      "URL",
      "UTF8",
      "VM",
      "XML",
      "XMPP",
      "XSRF",
      "XSS"
    ];

    return str
      .replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag) {
        if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
          return sep + frag.toUpperCase();
        else return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
      })
      .replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag) {
        if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
          return (sep + frag).toUpperCase();
        else return sep + frag;
      });
  }

  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      var r = (Math.random() * 16) | 0,
        v = c == "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  function getOriginalName(unique) {
    const reLiteralUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    const uuidLength = 36;

    if (unique.length >= uuidLength) {
      const tail = unique.substr(-uuidLength);
      if (reLiteralUUID.test(tail)) {
        return unique.slice(0, -1 * (uuidLength + 1));
      }
    }
    return unique;
  }

  function compareObjects(objectA, objectB) {
    const object = "[object Object]";
    return (
      Object.prototype.toString.call(objectA) === object &&
      Object.prototype.toString.call(objectB) === object
    );
  }

  function compareObjectKeys(itemAKeys, itemBKeys) {
    const lengthA = itemAKeys.length;
    const lengthB = itemBKeys.length;

    // nothing to compare, probably identical
    if (lengthA == 0 && lengthB == 0) return true;

    // duh
    if (lengthA != lengthB) return false;

    for (let item of itemAKeys) {
      if (!itemBKeys.includes(item)) return false;
    }
    return true;
  }

  function formatScopeKeys(keys) {
    for (let i in keys) {
      keys[i] = format(keys[i]);
    }
    return keys;
  }
}

if (typeof module != "undefined") {
  if (!module.parent) {
    if (process.argv.length > 2 && process.argv[2] === "-big") {
      bufs = [];
      process.stdin.on("data", function(buf) {
        bufs.push(buf);
      });
      process.stdin.on("end", function() {
        const json = Buffer.concat(bufs).toString("utf8");
        console.log(jsonToPython(json).python);
      });
    } else {
      process.stdin.on("data", function(buf) {
        const json = buf.toString("utf8");
        console.log(jsonToPython(json).python);
      });
    }
  } else {
    module.exports = jsonToPython;
  }
}
